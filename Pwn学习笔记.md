## Pwn学习笔记

1. 栈溢出。

   程序向栈中某个变量写入超出其本身所申请的字节数的数据，导致与其相邻的栈中变量的值被改变，是一种缓冲区溢出漏洞。

   最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，**当然需要确保这个地址所在的段具有可执行权限**。

   函数栈的布局

   ![img](https://images0.cnblogs.com/i/569008/201405/271650059007975.jpg)

   ![img](https://images0.cnblogs.com/i/569008/201405/271652449633815.jpg)

   栈溢出漏洞利用步骤

   - 寻找危险函数
     - 输入——gets（直接读一行，忽略'\x00'）、scanf、vscanf
     - 输出——sprintf
     - 字符串——strcpy（遇到'\x00'停止），strcat（遇到'\x00'停止）、bcopy
   - 确定填充长度
     - 通常是打开IDA，根据其给定地址计算偏移，一般是根据EBP相对偏移

2. ROP

   ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。

   - ret2text例子

     - 用checksec ret2text查看程序保护机制，可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。

     - 用ida查看程序发现其使用了gets函数，又发现secure函数在0x804863a处有调用 system("/bin/sh") 的代码，如果将gets函数的返回地址设置为0x804863a则可以获取目标的shell

     - 用gdb调试可以得到在调用gets函数之前，即call指令之前，$esp=0xffffcda0，$ebp=0xffffce28，而s的地址为esp+0x1c，所以s和ebp相差0x6c个字节，故和返回地址相差0x6c+4个字节。计算完距离编写脚本使其溢出即可。

       ```python
       #!/usr/bin/env python
       # coding=utf-8
       from pwn import *
       
       sh=process("./ret2text")
       arg='a'*(0x6c+4)+p32(0x804863a)
       sh.sendline(arg)
       sh.interactive()
       ```

3. 格式化字符串漏洞

   格式化字符串函数可以接受可变数量的参数，并将**第一个参数作为格式化字符串，根据其来解析之后的参数**。若格式化字符串函数给的参数不足，但是函数仍然会按照格式化字符串对相应地址的数据进行解析。如

   ```C
   printf("Color %s, Number %d, Float %4.2f");
   ```

   此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为字符串、整型和浮点值。对于后两者可能没有很大问题，但对于字符串，如果地址上放的是不可访问的地址，则会导致程序崩溃。